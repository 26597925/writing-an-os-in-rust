>原文：https://os.phil-opp.com/minimal-rust-kernel/
>
>原作者：@phil-opp
>
>译者：洛佳  华中科技大学

# 使用Rust创造操作系统（二）：第一个操作系统内核

在这篇文章中，我们将基于**x86架构**（the x86 architecture），使用Rust语言，创造一个最小化的64位操作系统内核。我们将从上一章中构建的独立式可执行程序开始，构建自己的内核；它将向显示器打印字符串，并能被打包为一个能够引导启动的**磁盘映像**（disk image）。

## 引导启动

当我们启动电脑时，主板ROM内存储的**固件**（firmware）将会运行：它将负责电脑的**上电自检**（power-on self test），**可用内存**（available RAM）的检测，以及CPU和其它硬件的预加载。这之后，它将寻找一个**可引导的存储介质**（bootable disk），并开始引导启动其中的操作系统内核。

x86架构支持两种固件标准：**BIOS**（Basic Input/Output System）和**UEFI**（Unified Extensible Firmware Interface）。其中，BIOS标准显得陈旧而过时，但实现简单，并为1980年代后的所有x86设备所支持；相反地，UEFI更现代化，功能也更全面，但开发和构建更复杂（至少从我的角度看是如此）。

在这篇文章中，我们暂时只提供BIOS固件的引导启动方式。

## BIOS启动

几乎所有的x86硬件系统都支持BIOS启动，这也包含新式的、基于UEFI、用**模拟BIOS**（emulated BIOS）的方式向后兼容的硬件系统。这可以说是一件好事情，因为无论是上世纪还是现在的硬件系统，你都只需编写同样的引导启动逻辑；但这种兼容性有时也是BIOS引导启动最大的缺点，因为这意味着在系统启动前，你的CPU必须先进入一个16位系统兼容的**实模式**（real mode），这样1980年代古老的引导固件才能够继续使用。

让我们从头开始，理解BIOS启动的过程。

当电脑启动时，主板上特殊的闪存中存储的BIOS固件将被加载。BIOS固件将会运行上电自检和硬件的初始化，然后它将寻找一个可引导的存储介质。如果找到了，那电脑的控制权将被转交给**引导程序**（bootloader）：一段存储在存储介质的开头的、512字节长度的程序片段。大多数的引导程序长度都大于512字节——所以通常情况下，引导程序都被切分成优先启动、长度不超过512字节、存储在介质开头的**第一阶段引导程序**（first stage bootloader），和随后由其加载的、长度可能较长、存储在其它位置的**第二阶段引导程序**（second stage bootloader）。

引导程序必须决定操作系统内核的位置，并将内核加载到内存。引导程序还需要将CPU从16位的实模式，先切换到32位的**保护模式**（protected mode），最终切换到64位的**长模式**（long mode）：此时，所有的64位寄存器和整个**主内存**（main memory）才能被访问。引导程序的第三个作用，是从BIOS查询特定的信息，并将其传递到操作系统内核，如查询和传递**内存映射表**（memory map）。

编写一个引导程序并不是一个简单的任务，因为它需要使用汇编语言编写，而且会经过许多并不是很显然的步骤——比如，把一些**魔术数字**（magic number）写入某个寄存器。因此，我们不会讲解如何编写自己的引导程序，而是推荐bootimage工具——它能够自动而方便地为你的内核准备一个引导程序。